<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>FracturedJson - Browser Formatter</title>

<script>

"use strict";
/*
 * FracturedJsonJs 2.0.0
 * FracturedJsonJs is a library for formatting JSON documents in a human-readable but fairly compact way.
 *
 * Copyright (c) 2021 Jesse Brooke
 * Project site: https://github.com/j-brooke/FracturedJsonJs
 * License: https://github.com/j-brooke/FracturedJsonJs/blob/main/LICENSE
 */
let exports = {};
/*
 * Class that outputs JSON formatted in a compact, user-readable way.  Any given container is formatted in one
 * of three ways:
 *   * Arrays or objects will be written on a single line, if their contents aren't too complex and the
 *     resulting line wouldn't be too long.
 *   * Arrays can be written on multiple lines, with multiple items per line, as long as those items aren't
 *     too complex.
 *   * Otherwise, each object property or array item is written beginning on its own line, indented one step
 *     deeper than its parent.
 */
class Formatter {
    constructor() {
        this._jsonEolStyle = EolStyle.lf;
        this._maxInlineLength = 80;
        this._maxInlineComplexity = 2;
        this._maxCompactArrayComplexity = 1;
        this._nestedBracketPadding = true;
        this._colonPadding = true;
        this._commaPadding = true;
        this._alwaysExpandDepth = -1;
        this._indentSpaces = 4;
        this._useTabToIndent = false;
        this._tableObjectMinimumSimilarity = 75;
        this._tableArrayMinimumSimilarity = 75;
        this._alignExpandedPropertyNames = false;
        this._dontJustifyNumbers = false;
        this._prefixString = "";
        this._eolStr = "";
        this._indentStr = "";
        this._paddedCommaStr = "";
        this._paddedColonStr = "";
        this._indentCache = [];
    }
    get jsonEolStyle() {
        return this._jsonEolStyle;
    }
    set jsonEolStyle(value) {
        this._jsonEolStyle = value;
    }
    get maxInlineLength() {
        return this._maxInlineLength;
    }
    set maxInlineLength(value) {
        this._maxInlineLength = value;
    }
    get maxInlineComplexity() {
        return this._maxInlineComplexity;
    }
    set maxInlineComplexity(value) {
        this._maxInlineComplexity = value;
    }
    get maxCompactArrayComplexity() {
        return this._maxCompactArrayComplexity;
    }
    set maxCompactArrayComplexity(value) {
        this._maxCompactArrayComplexity = value;
    }
    get nestedBracketPadding() {
        return this._nestedBracketPadding;
    }
    set nestedBracketPadding(value) {
        this._nestedBracketPadding = value;
    }
    get colonPadding() {
        return this._colonPadding;
    }
    set colonPadding(value) {
        this._colonPadding = value;
    }
    get commaPadding() {
        return this._commaPadding;
    }
    set commaPadding(value) {
        this._commaPadding = value;
    }
    get alwaysExpandDepth() {
        return this._alwaysExpandDepth;
    }
    set alwaysExpandDepth(value) {
        this._alwaysExpandDepth = value;
    }
    get indentSpaces() {
        return this._indentSpaces;
    }
    set indentSpaces(value) {
        this._indentSpaces = value;
    }
    get useTabToIndent() {
        return this._useTabToIndent;
    }
    set useTabToIndent(value) {
        this._useTabToIndent = value;
    }
    get tableObjectMinimumSimilarity() {
        return this._tableObjectMinimumSimilarity;
    }
    set tableObjectMinimumSimilarity(value) {
        this._tableObjectMinimumSimilarity = value;
    }
    get tableArrayMinimumSimilarity() {
        return this._tableArrayMinimumSimilarity;
    }
    set tableArrayMinimumSimilarity(value) {
        this._tableArrayMinimumSimilarity = value;
    }
    get alignExpandedPropertyNames() {
        return this._alignExpandedPropertyNames;
    }
    set alignExpandedPropertyNames(value) {
        this._alignExpandedPropertyNames = value;
    }
    get dontJustifyNumbers() {
        return this._dontJustifyNumbers;
    }
    set dontJustifyNumbers(value) {
        this._dontJustifyNumbers = value;
    }
    get prefixString() {
        return this._prefixString;
    }
    set prefixString(value) {
        this._prefixString = value;
    }
    serialize(jsValue) {
        this.initInternals();
        return this._prefixString + this.formatElement(0, jsValue).Value;
    }
    initInternals() {
        this._eolStr = (this._jsonEolStyle === EolStyle.Crlf) ? "\r\n" : "\n";
        this._indentStr = (this._useTabToIndent) ? "\t" : " ".repeat(this._indentSpaces);
        this._paddedCommaStr = (this._commaPadding) ? ", " : ",";
        this._paddedColonStr = (this._colonPadding) ? ": " : ":";
    }
    indent(buff, depth) {
        if (!this._indentCache[depth])
            this._indentCache[depth] = this._indentStr.repeat(depth);
        buff.push(this._prefixString, this._indentCache[depth]);
        return buff;
    }
    combine(buff) {
        return buff.join('');
    }
    formatElement(depth, element) {
        let formattedItem;
        if (Array.isArray(element))
            formattedItem = this.formatArray(depth, element);
        else if (element === null)
            formattedItem = this.formatSimple(depth, element);
        else if (typeof (element) === "object")
            formattedItem = this.formatObject(depth, element);
        else
            formattedItem = this.formatSimple(depth, element);
        formattedItem.cleanup();
        return formattedItem;
    }
    formatSimple(depth, element) {
        const simpleNode = new FormattedNode();
        simpleNode.Value = JSON.stringify(element);
        simpleNode.Complexity = 0;
        simpleNode.Depth = depth;
        simpleNode.Kind = JsonValueKind.Array;
        simpleNode.Format = Format.Inline;
        if (element === null) {
            simpleNode.Kind = JsonValueKind.Null;
            return simpleNode;
        }
        switch (typeof (element)) {
            case "boolean":
                simpleNode.Kind = JsonValueKind.Boolean;
                break;
            case "number":
                simpleNode.Kind = JsonValueKind.Number;
                break;
            case "undefined":
                simpleNode.Kind = JsonValueKind.Null;
                break;
            default:
            case "string":
                simpleNode.Kind = JsonValueKind.String;
                break;
        }
        return simpleNode;
    }
    formatArray(depth, element) {
        const items = element.map(child => this.formatElement(depth + 1, child));
        if (items.length === 0)
            return this.emptyArray(depth);
        const thisItem = new FormattedNode();
        thisItem.Kind = JsonValueKind.Array;
        thisItem.Complexity = Math.max(...items.map(fn => fn.Complexity)) + 1;
        thisItem.Depth = depth;
        thisItem.Children = items;
        if (thisItem.Depth > this._alwaysExpandDepth) {
            if (this.formatArrayInline(thisItem)) {
                return thisItem;
            }
        }
        this.justifyParallelNumbers(thisItem.Children);
        if (thisItem.Depth > this._alwaysExpandDepth) {
            if (this.formatArrayMultilineCompact(thisItem)) {
                return thisItem;
            }
        }
        if (this.formatTableArrayObject(thisItem))
            return thisItem;
        if (this.formatTableArrayArray(thisItem))
            return thisItem;
        this.formatArrayExpanded(thisItem);
        return thisItem;
    }
    formatObject(depth, element) {
        const items = Object.entries(element)
            .map(kvp => this.formatElement(depth + 1, kvp[1]).withName(kvp[0]));
        if (items.length === 0)
            return this.emptyObject(depth);
        const thisItem = new FormattedNode();
        thisItem.Kind = JsonValueKind.Object;
        thisItem.Complexity = Math.max(...items.map(fn => fn.Complexity)) + 1;
        thisItem.Depth = depth;
        thisItem.Children = items;
        if (thisItem.Depth > this._alwaysExpandDepth) {
            if (this.formatObjectInline(thisItem)) {
                return thisItem;
            }
        }
        if (this.formatTableObjectObject(thisItem))
            return thisItem;
        if (this.formatTableObjectArray(thisItem))
            return thisItem;
        this.formatObjectExpanded(thisItem, false);
        return thisItem;
    }
    emptyArray(depth) {
        const arr = new FormattedNode();
        arr.Value = "[]";
        arr.Complexity = 0;
        arr.Depth = depth;
        arr.Kind = JsonValueKind.Array;
        arr.Format = Format.Inline;
        return arr;
    }
    formatArrayInline(thisItem) {
        if (thisItem.Complexity > this._maxInlineComplexity)
            return false;
        const useNestedBracketPadding = (this._nestedBracketPadding && thisItem.Complexity >= 2);
        const lineLength = 2 + (useNestedBracketPadding ? 2 : 0)
            + (thisItem.Children.length - 1) * this._paddedCommaStr.length
            + thisItem.Children.map(fn => fn.Value.length).reduce((acc, item) => acc + item);
        if (lineLength > this._maxInlineLength)
            return false;
        const buff = [];
        buff.push('[');
        if (useNestedBracketPadding)
            buff.push(' ');
        let firstElem = true;
        for (const child of thisItem.Children) {
            if (!firstElem)
                buff.push(this._paddedCommaStr);
            buff.push(child.Value);
            firstElem = false;
        }
        if (useNestedBracketPadding)
            buff.push(' ');
        buff.push(']');
        thisItem.Value = this.combine(buff);
        thisItem.Format = Format.Inline;
        return true;
    }
    formatArrayMultilineCompact(thisItem) {
        if (thisItem.Complexity > this._maxCompactArrayComplexity)
            return false;
        const buff = [];
        buff.push('[', this._eolStr);
        this.indent(buff, thisItem.Depth + 1);
        let lineLengthSoFar = 0;
        let childIndex = 0;
        while (childIndex < thisItem.Children.length) {
            const notLastItem = childIndex < thisItem.Children.length - 1;
            const itemLength = thisItem.Children[childIndex].Value.length;
            const segmentLength = itemLength + ((notLastItem) ? this._paddedCommaStr.length : 0);
            if (lineLengthSoFar + segmentLength > this._maxInlineLength && lineLengthSoFar > 0) {
                buff.push(this._eolStr);
                this.indent(buff, thisItem.Depth + 1);
                lineLengthSoFar = 0;
            }
            buff.push(thisItem.Children[childIndex].Value);
            if (notLastItem)
                buff.push(this._paddedCommaStr);
            childIndex += 1;
            lineLengthSoFar += segmentLength;
        }
        buff.push(this._eolStr);
        this.indent(buff, thisItem.Depth);
        buff.push(']');
        thisItem.Value = this.combine(buff);
        thisItem.Format = Format.MultilineCompact;
        return true;
    }
    formatTableArrayObject(thisItem) {
        if (this._tableObjectMinimumSimilarity > 100.5)
            return false;
        const colStats = this.getPropertyStats(thisItem);
        if (!colStats)
            return false;
        for (const child of thisItem.Children)
            this.formatObjectTableRow(child, colStats);
        return this.formatArrayExpanded(thisItem);
    }
    formatTableArrayArray(thisItem) {
        if (this._tableArrayMinimumSimilarity > 100.5)
            return false;
        const columnStats = this.getArrayStats(thisItem);
        if (!columnStats)
            return false;
        for (const child of thisItem.Children)
            this.formatArrayTableRow(child, columnStats);
        return this.formatArrayExpanded(thisItem);
    }
    formatArrayTableRow(thisItem, columnStatsArray) {
        const buff = [];
        buff.push("[ ");
        for (let index = 0; index < thisItem.Children.length; ++index) {
            if (index)
                buff.push(this._paddedCommaStr);
            const columnStats = columnStatsArray[index];
            buff.push(columnStats.formatValue(thisItem.Children[index].Value, this._dontJustifyNumbers));
        }
        for (let index = thisItem.Children.length; index < columnStatsArray.length; ++index) {
            const padSize = columnStatsArray[index].MaxValueSize
                + ((index === 0) ? 0 : this._paddedCommaStr.length);
            buff.push(' '.repeat(padSize));
        }
        buff.push(" ]");
        thisItem.Value = this.combine(buff);
        thisItem.Format = Format.InlineTabular;
    }
    formatArrayExpanded(thisItem) {
        const buff = [];
        buff.push('[', this._eolStr);
        let firstElem = true;
        for (const child of thisItem.Children) {
            if (!firstElem)
                buff.push(',', this._eolStr);
            this.indent(buff, child.Depth).push(child.Value);
            firstElem = false;
        }
        buff.push(this._eolStr);
        this.indent(buff, thisItem.Depth).push(']');
        thisItem.Value = this.combine(buff);
        thisItem.Format = Format.Expanded;
        return true;
    }
    emptyObject(depth) {
        const obj = new FormattedNode();
        obj.Value = "{}";
        obj.Complexity = 0;
        obj.Depth = depth;
        obj.Kind = JsonValueKind.Object;
        obj.Format = Format.Inline;
        return obj;
    }
    formatObjectInline(thisItem) {
        if (thisItem.Complexity > this._maxInlineComplexity)
            return false;
        const useNestedBracketPadding = (this._nestedBracketPadding && thisItem.Complexity >= 2);
        const lineLength = 2 + (useNestedBracketPadding ? 2 : 0)
            + thisItem.Children.length * this._paddedColonStr.length
            + (thisItem.Children.length - 1) * this._paddedCommaStr.length
            + thisItem.Children.length * 2
            + thisItem.Children.map(fn => fn.Name.length).reduce((acc, item) => acc + item)
            + thisItem.Children.map(fn => fn.Value.length).reduce((acc, item) => acc + item);
        if (lineLength > this._maxInlineLength)
            return false;
        const buff = [];
        buff.push('{');
        if (useNestedBracketPadding)
            buff.push(' ');
        let firstElem = true;
        for (const prop of thisItem.Children) {
            if (!firstElem)
                buff.push(this._paddedCommaStr);
            buff.push('"', prop.Name, '"', this._paddedColonStr, prop.Value);
            firstElem = false;
        }
        if (useNestedBracketPadding)
            buff.push(' ');
        buff.push('}');
        thisItem.Value = this.combine(buff);
        thisItem.Format = Format.Inline;
        return true;
    }
    formatTableObjectObject(thisItem) {
        if (this._tableObjectMinimumSimilarity > 100.5)
            return false;
        const propStats = this.getPropertyStats(thisItem);
        if (!propStats)
            return false;
        for (const child of thisItem.Children)
            this.formatObjectTableRow(child, propStats);
        return this.formatObjectExpanded(thisItem, true);
    }
    formatTableObjectArray(thisItem) {
        if (this._tableArrayMinimumSimilarity > 100.5)
            return false;
        const columnStats = this.getArrayStats(thisItem);
        if (!columnStats)
            return false;
        for (const child of thisItem.Children)
            this.formatArrayTableRow(child, columnStats);
        return this.formatObjectExpanded(thisItem, true);
    }
    formatObjectTableRow(thisItem, columnStatsArray) {
        let highestNonBlankIndex = -1;
        const propSegmentStrings = [];
        for (let colIndex = 0; colIndex < columnStatsArray.length; ++colIndex) {
            const buff = [];
            const columnStats = columnStatsArray[colIndex];
            const filteredPropNodes = thisItem.Children.filter(fn => fn.Name === columnStats.PropName);
            if (filteredPropNodes.length === 0) {
                const skipLength = 2
                    + columnStats.PropName.length
                    + this._paddedColonStr.length
                    + columnStats.MaxValueSize;
                buff.push(' '.repeat(skipLength));
            }
            else {
                const propNode = filteredPropNodes[0];
                buff.push('"', columnStats.PropName, '"', this._paddedColonStr);
                buff.push(columnStats.formatValue(propNode.Value, this._dontJustifyNumbers));
                highestNonBlankIndex = colIndex;
            }
            propSegmentStrings[colIndex] = this.combine(buff);
        }
        const buff = [];
        buff.push("{ ");
        let firstElem = true;
        let needsComma = false;
        for (let segmentIndex = 0; segmentIndex < propSegmentStrings.length; ++segmentIndex) {
            if (needsComma && segmentIndex <= highestNonBlankIndex)
                buff.push(this._paddedCommaStr);
            else if (!firstElem)
                buff.push(' '.repeat(this._paddedCommaStr.length));
            buff.push(propSegmentStrings[segmentIndex]);
            needsComma = (propSegmentStrings[segmentIndex].trim().length !== 0);
            firstElem = false;
        }
        buff.push(" }");
        thisItem.Value = this.combine(buff);
        thisItem.Format = Format.InlineTabular;
    }
    formatObjectExpanded(thisItem, forceExpandPropNames) {
        const maxPropNameLength = Math.max(...thisItem.Children.map(fn => fn.Name.length));
        const buff = [];
        buff.push('{', this._eolStr);
        let firstItem = true;
        for (const prop of thisItem.Children) {
            if (!firstItem)
                buff.push(',', this._eolStr);
            this.indent(buff, prop.Depth).push('"', prop.Name, '"');
            if (this._alignExpandedPropertyNames || forceExpandPropNames)
                buff.push(' '.repeat(maxPropNameLength - prop.Name.length));
            buff.push(this._paddedColonStr, prop.Value);
            firstItem = false;
        }
        buff.push(this._eolStr);
        this.indent(buff, thisItem.Depth).push('}');
        thisItem.Value = this.combine(buff);
        thisItem.Format = Format.Expanded;
        return true;
    }
    justifyParallelNumbers(itemList) {
        if (itemList.length < 2 || this._dontJustifyNumbers)
            return;
        const columnStats = new ColumnStats();
        for (const propNode of itemList)
            columnStats.update(propNode, 0);
        if (!columnStats.IsQualifiedNumeric)
            return;
        for (const propNode of itemList)
            propNode.Value = columnStats.formatValue(propNode.Value, this._dontJustifyNumbers);
    }
    getPropertyStats(thisItem) {
        if (thisItem.Children.length < 2)
            return null;
        const props = {};
        for (const child of thisItem.Children) {
            if (child.Kind !== JsonValueKind.Object || child.Format !== Format.Inline)
                return null;
            for (let index = 0; index < child.Children.length; ++index) {
                const propNode = child.Children[index];
                let propStats = props[propNode.Name];
                if (!propStats) {
                    propStats = new ColumnStats();
                    propStats.PropName = propNode.Name;
                    props[propStats.PropName] = propStats;
                }
                propStats.update(propNode, index);
            }
        }
        const orderedProps = Object.values(props)
            .sort((a, b) => (a.OrderSum / a.Count) - (b.OrderSum / b.Count));
        const totalPropCount = orderedProps.map(cs => cs.Count).reduce((acc, item) => acc + item);
        const score = 100 * totalPropCount / (orderedProps.length * thisItem.Children.length);
        if (score < this._tableObjectMinimumSimilarity)
            return null;
        const lineLength = 4
            + 2 * orderedProps.length
            + orderedProps.map(cs => cs.PropName.length).reduce((acc, item) => acc + item)
            + this._paddedColonStr.length * orderedProps.length
            + orderedProps.map(cs => cs.MaxValueSize).reduce((acc, item) => acc + item)
            + this._paddedCommaStr.length * (orderedProps.length - 1);
        if (lineLength > this._maxInlineLength)
            return null;
        return orderedProps;
    }
    getArrayStats(thisItem) {
        if (thisItem.Children.length < 2)
            return null;
        const valid = thisItem.Children.every(fn => fn.Kind === JsonValueKind.Array && fn.Format === Format.Inline);
        if (!valid)
            return null;
        const numberOfColumns = Math.max(...thisItem.Children.map(fn => fn.Children.length));
        const colStatsArray = [];
        for (let i = 0; i < numberOfColumns; ++i)
            colStatsArray[i] = new ColumnStats();
        for (const rowNode of thisItem.Children) {
            for (let index = 0; index < rowNode.Children.length; ++index)
                colStatsArray[index].update(rowNode.Children[index], index);
        }
        const totalElemCount = thisItem.Children.map(fn => fn.Children.length).reduce((acc, item) => acc + item);
        const similarity = 100 * totalElemCount / (thisItem.Children.length * numberOfColumns);
        if (similarity < this._tableArrayMinimumSimilarity)
            return null;
        const lineLength = 4
            + colStatsArray.map(cs => cs.MaxValueSize).reduce((acc, item) => acc + item)
            + (colStatsArray.length - 1) * this._paddedCommaStr.length;
        if (lineLength > this._maxInlineLength)
            return null;
        return colStatsArray;
    }
}
exports.Formatter = Formatter;
var EolStyle;
(function (EolStyle) {
    EolStyle[EolStyle["Crlf"] = 0] = "Crlf";
    EolStyle[EolStyle["lf"] = 1] = "lf";
})(EolStyle = exports.EolStyle || (exports.EolStyle = {}));
var JsonValueKind;
(function (JsonValueKind) {
    JsonValueKind[JsonValueKind["Undefined"] = 0] = "Undefined";
    JsonValueKind[JsonValueKind["Object"] = 1] = "Object";
    JsonValueKind[JsonValueKind["Array"] = 2] = "Array";
    JsonValueKind[JsonValueKind["String"] = 3] = "String";
    JsonValueKind[JsonValueKind["Number"] = 4] = "Number";
    JsonValueKind[JsonValueKind["Boolean"] = 5] = "Boolean";
    JsonValueKind[JsonValueKind["Null"] = 6] = "Null";
})(JsonValueKind || (JsonValueKind = {}));
class ColumnStats {
    constructor() {
        this.PropName = "";
        this.OrderSum = 0;
        this.Count = 0;
        this.MaxValueSize = 0;
        this.IsQualifiedNumeric = true;
        this.CharsBeforeDec = 0;
        this.CharsAfterDec = 0;
    }
    update(propNode, index) {
        this.OrderSum += index;
        this.Count += 1;
        this.MaxValueSize = Math.max(this.MaxValueSize, propNode.Value.length);
        this.IsQualifiedNumeric = this.IsQualifiedNumeric && (propNode.Kind === JsonValueKind.Number);
        if (!this.IsQualifiedNumeric)
            return;
        const normalizedNum = Number(propNode.Value).toString();
        this.IsQualifiedNumeric = this.IsQualifiedNumeric && !(normalizedNum.includes("e") || normalizedNum.includes("E"));
        if (!this.IsQualifiedNumeric)
            return;
        const decIndex = normalizedNum.indexOf(".");
        if (decIndex < 0) {
            this.CharsBeforeDec = Math.max(this.CharsBeforeDec, normalizedNum.length);
        }
        else {
            this.CharsBeforeDec = Math.max(this.CharsBeforeDec, decIndex);
            this.CharsAfterDec = Math.max(this.CharsAfterDec, normalizedNum.length - decIndex - 1);
        }
    }
    formatValue(value, dontJustify) {
        if (this.IsQualifiedNumeric && !dontJustify) {
            const adjustedVal = Number(value).toFixed(this.CharsAfterDec);
            const totalLength = this.CharsBeforeDec + this.CharsAfterDec + ((this.CharsAfterDec > 0) ? 1 : 0);
            return adjustedVal.padStart(totalLength);
        }
        return value.padEnd(this.MaxValueSize);
    }
}
var Format;
(function (Format) {
    Format[Format["Inline"] = 0] = "Inline";
    Format[Format["InlineTabular"] = 1] = "InlineTabular";
    Format[Format["MultilineCompact"] = 2] = "MultilineCompact";
    Format[Format["Expanded"] = 3] = "Expanded";
})(Format || (Format = {}));
class FormattedNode {
    constructor() {
        this.Name = "";
        this.Value = "";
        this.Complexity = 0;
        this.Depth = 0;
        this.Kind = JsonValueKind.Undefined;
        this.Format = Format.Inline;
        this.Children = [];
    }
    withName(name) {
        this.Name = name;
        return this;
    }
    cleanup() {
        if (this.Format !== Format.Inline)
            this.Children = [];
        for (const child of this.Children)
            child.Children = [];
    }
}

</script>

<script>
    function doFormat(formatType) {
        const outputElem = document.getElementById("jsonOutput");
        outputElem.value = "";

        const inputVal = document.getElementById("jsonInput").value;

        let outputVal = "";
        try {
            const objFormOfInput = JSON.parse(inputVal);

            if (formatType=="minify") {
                outputVal = JSON.stringify(objFormOfInput);
            }
            else if (formatType=="near") {
                const format = new Formatter();
                format.maxInlineLength = 1000000000;
                format.maxInlineComplexity = 1000000000;
                format.maxCompactArrayComplexity = 1000000000;
                format.alwaysExpandDepth = 0;
                format.alignExpandedPropertyNames = false;
                format.nestedBracketPadding = false;
                format.colonPadding = false;
                format.commaPadding = false;
                format.indentSpaces = 0;
                format.useTabToIndent = false;
                format.tableObjectMinimumSimilarity = 101;
                format.tableArrayMinimumSimilarity = 101;

                outputVal = format.serialize(objFormOfInput);
            }
            else {
                const format = new Formatter();
                format.maxInlineLength = Number(document.getElementById("maxInlineLength").value);
                format.maxInlineComplexity = Number(document.getElementById("maxInlineComplexity").value);
                format.maxCompactArrayComplexity = Number(document.getElementById("maxCompactArrayComplexity").value);
                format.alwaysExpandDepth = Number(document.getElementById("alwaysExpandDepth").value);
                format.alignExpandedPropertyNames = document.getElementById("alignExpandedPropertyNames").checked;
                format.nestedBracketPadding = document.getElementById("nestedBracketPadding").checked;
                format.colonPadding = document.getElementById("colonPadding").checked;
                format.commaPadding = document.getElementById("commaPadding").checked;
                format.dontJustifyNumbers = document.getElementById("dontJustifyNumbers").checked;
                format.tableObjectMinimumSimilarity = Number(document.getElementById("tableObjectMinimumSimilarity").value);
                format.tableArrayMinimumSimilarity = Number(document.getElementById("tableArrayMinimumSimilarity").value);

                const indentCode = document.getElementById("indentCode").value;
                if (indentCode==="tab"){
                    format.useTabToIndent = true;
                } else {
                    format.useTabToIndent = false;
                    format.indentSpaces = Number(indentCode);
                }

                outputVal = format.serialize(objFormOfInput);
            }
        }
        catch (ex) {
            outputVal = String(ex);
        }

        outputElem.value = outputVal;
    }

    function sampleData() {
        const data = {"SimpleArray":[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113],"ObjectColumnsArrayRows":{"Katherine":["blue","lightblue","black"],"Logan":["yellow","blue","black","red"],"Erik":["red","purple"],"Jean":["lightgreen","yellow","black"]},"ArrayColumnsObjectRows":[{"hp":400,"type":"turret","loc":{"x":47,"y":-4},"flags":"S"},{"type":"assassin","hp":80,"loc":{"x":12,"y":6},"flags":"Q"},{"type":"berserker","hp":150,"loc":{"x":0,"y":0}},{"loc":{"x":10,"y":-14},"type":"pittrap","flags":"S,I"}],"ComplexArray":[[19,2],[3,8],[14,0],[9,9],[9,9],[0,3],[10,1],[9,1],[9,2],[6,13],[18,5],[4,11],[12,2]]};
        document.getElementById("jsonInput").value = JSON.stringify(data);
    }

    function saveOptions() {
        localStorage["maxInlineLength"] = document.getElementById("maxInlineLength").value;
        localStorage["maxInlineComplexity"] = document.getElementById("maxInlineComplexity").value;
        localStorage["maxCompactArrayComplexity"] = document.getElementById("maxCompactArrayComplexity").value;
        localStorage["alwaysExpandDepth"] = document.getElementById("alwaysExpandDepth").value;
        localStorage["alignExpandedPropertyNames"] = document.getElementById("alignExpandedPropertyNames").checked;
        localStorage["nestedBracketPadding"] = document.getElementById("nestedBracketPadding").checked;
        localStorage["colonPadding"] = document.getElementById("colonPadding").checked;
        localStorage["commaPadding"] = document.getElementById("commaPadding").checked;
        localStorage["dontJustifyNumbers"] = document.getElementById("dontJustifyNumbers").checked;
        localStorage["tableObjectMinimumSimilarity"] = document.getElementById("tableObjectMinimumSimilarity").value;
        localStorage["tableArrayMinimumSimilarity"] = document.getElementById("tableArrayMinimumSimilarity").value;
        localStorage["indentCode"] = document.getElementById("indentCode").value;
    }

    function loadOptions() {
        if (typeof(Storage) == "undefined")
            return;

        const defaults = new Formatter();
        document.getElementById("maxInlineLength").value = Number(localStorage["maxInlineLength"] || defaults.maxInlineLength);
        document.getElementById("maxInlineComplexity").value = Number(localStorage["maxInlineComplexity"] || defaults.maxInlineComplexity);
        document.getElementById("maxCompactArrayComplexity").value = Number(localStorage["maxCompactArrayComplexity"] || defaults.maxCompactArrayComplexity);
        document.getElementById("alwaysExpandDepth").value = Number(localStorage["alwaysExpandDepth"] || defaults.alwaysExpandDepth);
        document.getElementById("alignExpandedPropertyNames").checked = boolOrDefault(localStorage["alignExpandedPropertyNames"], defaults.alignExpandedPropertyNames);
        document.getElementById("nestedBracketPadding").checked = boolOrDefault(localStorage["nestedBracketPadding"], defaults.nestedBracketPadding);
        document.getElementById("colonPadding").checked = boolOrDefault(localStorage["colonPadding"], defaults.colonPadding);
        document.getElementById("commaPadding").checked = boolOrDefault(localStorage["commaPadding"], defaults.commaPadding);
        document.getElementById("dontJustifyNumbers").checked = boolOrDefault(localStorage["dontJustifyNumbers"], defaults.dontJustifyNumbers);
        document.getElementById("tableObjectMinimumSimilarity").value = Number(localStorage["tableObjectMinimumSimilarity"] || defaults.tableObjectMinimumSimilarity);
        document.getElementById("tableArrayMinimumSimilarity").value = Number(localStorage["tableArrayMinimumSimilarity"] || defaults.tableArrayMinimumSimilarity);
        document.getElementById("indentCode").value = (localStorage["indentCode"]!==undefined)? localStorage["indentCode"] : defaults.indentSpaces.toString();
    }

    function boolOrDefault(stored, defaultVal) {
        return (stored===undefined)? defaultVal : (stored==="true");
    }

    function resetOptions() {
        localStorage.clear();
        loadOptions();
    }
</script>

<style>
    body {
        background-color: lightblue;
    }

    button {
        font-size: large;
    }

    textarea {
        width: 100%;
    }

    h1 {
        margin-top: 0em;
    }

    .json-box {
        background-color: aliceblue;
        font-family: monospace;
    }

    .option-group {
        float: left;
        padding: 0.2em 0.2em 0.5em 0.5em;
    }

    .buttons {
        padding: 0.2em 0.2em 0.5em 0.5em;
    }

    .warning-box {
        background-color: coral;
        border-style: solid;
        border-width: medium;
        padding: 1.2em 1.2em 1.2em 1.2em;
        font-size: larger;
    }

    .icon {
        float: left;
        width: 160px;
    }

    .unfloat {
        clear:both;
    }

    .intro-text {
        float: left;
    }
</style>
</head>

<body onload="loadOptions()">
    <img src="logo_256.png" class="icon"/>
    <div class="intro-text">
        <h1>FracturedJson</h1>
        <p>A JSON formatter that produces human-readable but fairly compact output.</p>
        <ul>
            <li>Arrays and objects are written on single lines, if their contents aren't too complex
            and the resulting line wouldn't be too long.</li>
            <li>Arrays can be written on multiple lines, with multiple items per line, as long as those
            items aren't too complex.</li>
            <li>Otherwise, each object property or array item is written begining on its own line, indented
            one step deeper than its parent.</li>
        </ul>
    </div>

    <div class="unfloat"></div>

    <hr />
    <div>
        <a href="https://github.com/j-brooke/FracturedJson/wiki">Wiki</a>
        &mdash;
        <a href="https://j-brooke.github.io/FracturedJson/">Browser</a>
        &mdash;
        <a href="https://github.com/j-brooke/FracturedJson/wiki/.NET-Library">.NET Library</a>
        <a href="https://www.nuget.org/packages/FracturedJson">(NuGet)</a>
        &mdash;
        <a href="https://github.com/j-brooke/FracturedJsonJs">Javascript Module</a>
        <a href="https://www.npmjs.com/package/fracturedjsonjs">(npm)</a>
        &mdash;
        <a href="https://marketplace.visualstudio.com/items?itemName=j-brooke.fracturedjsonvsc">VS Code extension</a>
    </div>
    <hr />

    <div>
        <form spellcheck="false">
            <noscript>
                <p class="warning-box">Please enable Javascript to use the formatter.  All processing is done client-side; your data isn't sent anywhere.</p>
            </noscript>

            <div>
                <div><label for="jsonInput">JSON Input:</label></div>
                <textarea class="json-box" autofocus rows="15" cols="100" id="jsonInput" placeholder="Paste your favorite JSON data here, or press the Sample Data button"></textarea>
            </div>

            <div>
                <div class="option-container">
                    <div class="option-group">
                        <div><input type="number" onchange="saveOptions()" min="0" step="10" value="80" id="maxInlineLength">Maximum Inline Length</input></div>
                        <div><input type="number" onchange="saveOptions()" min="0" value="2" id="maxInlineComplexity">Maximum Inline Complexity</input></div>
                        <div><input type="number" onchange="saveOptions()" min="0" value="1" id="maxCompactArrayComplexity">Maximum Compact Array Complexity</input></div>
                        <div><input type="number" onchange="saveOptions()" value="-1" id="alwaysExpandDepth">Always-Expand Depth</input></div>
                    </div>
                    <div class="option-group">
                        <div><input type="checkbox" onchange="saveOptions()" checked="false" id="alignExpandedPropertyNames">Align Property Names</input></div>
                        <div><input type="checkbox" onchange="saveOptions()" checked="true" id="nestedBracketPadding">Nested Bracket Padding</input></div>
                        <div><input type="checkbox" onchange="saveOptions()" checked="true" id="colonPadding">Colon Padding</input></div>
                        <div><input type="checkbox" onchange="saveOptions()" checked="true" id="commaPadding">Comma Padding</input></div>
                        <div><input type="checkbox" onchange="saveOptions()" checked="false" id="dontJustifyNumbers">Don't Justify Numbers</input></div>
                    </div>

                    <div class="option-group">
                        <div><input type="number" onchange="saveOptions()" min="0" step="12.5" value="75" id="tableObjectMinimumSimilarity">Table Object Minimum Similarity</input></div>
                        <div><input type="number" onchange="saveOptions()" min="0" step="12.5" value="75" id="tableArrayMinimumSimilarity">Table Array Minimum Similarity</input></div>
                        <select name="indentCode" id="indentCode" onchange="saveOptions()">
                            <option value="0">None</option>
                            <option value="tab">Tab</option>
                            <option value="1">1 Space</option>
                            <option value="2">2 Spaces</option>
                            <option value="3">3 Spaces</option>
                            <option value="4" selected="true">4 Spaces</option>
                            <option value="5">5 Spaces</option>
                            <option value="6">6 Spaces</option>
                            <option value="7">7 Spaces</option>
                            <option value="8">8 Spaces</option>
                        </select>
                        <label for="indentCode">Indentation</label><br/>
                        <a href="https://github.com/j-brooke/FracturedJson/wiki/Options" target="_blank">Option Help</a>
                    </div>

                    <div class="option-group"></div>
                </div>

                <div class="unfloat"></div>

                <div class="buttons">
                    <button type="button" onclick="doFormat('format')">Format</button>
                    <button type="button" onclick="doFormat('minify')">Minify</button>
                    <button type="button" onclick="doFormat('near')">Near-Minify</button>
                    <button type="button" onClick="sampleData()">Sample Data</button>
                    <button type="button" onClick="resetOptions()">Reset Options</button>
                </div>
            </div>

            <div>
                <div><label for="jsonOutput">Formatted Output:</label></div>
                <textarea class="json-box" rows="15" cols="100" id="jsonOutput" placeholder="Formatted JSON will appear here"></textarea>
            </div>
        </form>
    </div>

</body>
</html>
